using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using Libcuda.Versions;
using Libptx.Common;
using Libptx.Common.Performance;
using Libptx.Common.Types;
using Libptx.Expressions;
using Libptx.Expressions.Immediate;
using Libptx.Expressions.Slots;
using Libptx.Expressions.Sregs;
using Libptx.Instructions;
using Libptx.Reflection;
using Libptx.Statements;
using XenoGears.Assertions;
using XenoGears.Functional;
using XenoGears.Strings;

namespace Libptx
{
    [DebuggerNonUserCode]
    public class Entry : Atom
    {
        private String _name = null;
        public virtual String Name
        {
            get { return _name; }
            set { _name = value; }
        }

        private Tuning _tuning = new Tuning();
        public virtual Tuning Tuning
        {
            get { return _tuning; }
            set { _tuning = value ?? new Tuning(); }
        }

        private Params _params = new Params();
        public virtual Params Params
        {
            get { return _params; }
            set { _params = value ?? new Params(); }
        }

        private IList<Statement> _stmts = new List<Statement>();
        public virtual IList<Statement> Stmts
        {
            get { return _stmts; }
            set { _stmts = value ?? new List<Statement>(); }
        }

        protected override void CustomValidate(Module ctx)
        {
            // if name is null, it'll be autogenerated by Module::Validate
            if (Name != null) Name.ValidateName();
            // uniqueness of names is validated by Module

            Tuning.Validate(ctx);

            var size_limit = 256;
            if (ctx.Version >= SoftwareIsa.PTX_15) size_limit += 4096;
            // opaque types don't count against parameter list size limit
            (Params.Sum(p => p.SizeInMemory()) <= size_limit).AssertTrue();

            Params.ForEach(p =>
            {
                p.AssertNotNull();
                p.Validate(ctx);
                (p.Space == param).AssertTrue();
            });

            var slots = new HashSet<Slot>(Params.Cast<Slot>());
            var lbl_refs = new HashSet<Label>();
            var lbl_marks = new HashSet<Label>();
            Stmts.ForEach(stmt =>
            {
                stmt.AssertNotNull();
                stmt.Validate(ctx);

                var op = stmt as ptxop;
                if (op != null) op.Operands.ForEach(arg =>
                {
                    Action<Expression> extract_vars = null;
                    extract_vars = e =>
                    {
                        var e_reg = e as Reg;
                        if (e_reg != null) slots.Add(e_reg);

                        var e_var = e as Var;
                        if (e_var != null) slots.Add(e_var);

                        var e_sreg = e as Sreg;
                        if (e_sreg != null) return;

                        var e_const = e as Const;
                        if (e_const != null) return;

                        var e_warp_sz = e as WarpSz;
                        if (e_warp_sz != null) return;

                        var e_vec = e as Vector;
                        if (e_vec != null) e_vec.Flatten().ForEach(e_sub => extract_vars(e_sub));

                        var e_label = e as Label;
                        if (e_label != null) lbl_refs.Add(e_label);

                        var e_modded = e as Modded;
                        if (e_modded != null) e_modded.Flatten().ForEach(e_sub => extract_vars(e_sub));
                    };

                    extract_vars(arg);
                });

                var lbl = stmt as Label;
                if (lbl != null)
                {
                    var dup = lbl_marks.Add(lbl);
                    dup.AssertFalse();
                }
            });

            slots.ForEach(s =>
            {
                if (s.Name == null)
                {
                    Func<String> prefix = () =>
                    {
                        var s_reg = s as Reg;
                        if (s_reg != null)
                        {
                            Func<String> basis = () =>
                            {
                                switch (s_reg.Type.Name)
                                {
                                    case TypeName.U8:
                                        return "rhh";
                                    case TypeName.S8:
                                        return "rhhs";
                                    case TypeName.U16:
                                        return "rhh";
                                    case TypeName.S16:
                                        return "rhs";
                                    case TypeName.U32:
                                        return "r";
                                    case TypeName.S32:
                                        return "rs";
                                    case TypeName.U64:
                                        return "rd";
                                    case TypeName.S64:
                                        return "rds";
                                    case TypeName.F16:
                                        return "fh";
                                    case TypeName.F32:
                                        return "f";
                                    case TypeName.F64:
                                        return "fd";
                                    case TypeName.B8:
                                        return "bhh";
                                    case TypeName.B16:
                                        return "bh";
                                    case TypeName.B32:
                                        return "b";
                                    case TypeName.B64:
                                        return "bd";
                                    case TypeName.Pred:
                                        return "p";
                                    default:
                                        throw AssertionHelper.Fail();
                                }
                            };

                            String vec = null;
                            if (!s_reg.is_vec()) vec = String.Empty;
                            else if (s_reg.is_v1()) vec = "v1_";
                            else if (s_reg.is_v2()) vec = "v2_";
                            else if (s_reg.is_v4()) vec = "v4_";
                            else throw AssertionHelper.Fail();

                            s_reg.is_arr().AssertFalse();
                            return vec + basis;
                        }

                        var s_var = s as Var;
                        if (s_var != null) return "var";

                        throw AssertionHelper.Fail();
                    };

                    Func<int, String> gen_name = i => String.Format("%{0}{1}", prefix(), i);
                    var gend_name = Seq.Nats.Select(gen_name).First(name => slots.None(s2 => s2.Name == name));
                    s.Name = gend_name;
                }

                (slots.Count(s2 => s2.Name == s.Name) == 1).AssertTrue();
                Sregs.Sigs.Contains(s.Name).AssertFalse();
            });

            lbl_refs.IsSubsetOf(lbl_marks).AssertTrue();
            lbl_marks.ForEach(lbl =>
            {
                if (lbl.Name == null)
                {
                    Func<int, String> gen_name = i => String.Format("%lbl{0}", i);
                    var gend_name = Seq.Nats.Select(gen_name).First(name => slots.None(s2 => s2.Name == name));
                    lbl.Name = gend_name;
                }

                (lbl_marks.Count(lbl2 => lbl2.Name == lbl.Name) == 1).AssertTrue();
                Sregs.Sigs.Contains(lbl.Name).AssertFalse();
            });
        }

        protected override void RenderAsPtx(TextWriter writer)
        {
            writer = writer.Indented();
            Action indent = () => ((IndentedTextWriter)writer).Indent++;
            Action outdent = () => ((IndentedTextWriter)writer).Indent--;

            (Name != null).AssertTrue();
            writer.Write(".entry {0}", Name);

            var nontrivial_tuning = Tuning.Version > SoftwareIsa.PTX_10;
            var nonempty_pragmas = Pragmas.IsNotEmpty();
            if (Params.IsEmpty())
            {
                if (nontrivial_tuning) writer.WriteLine();
                Tuning.RenderAsPtx(writer);

                if (nonempty_pragmas) writer.WriteLine();
                Pragmas.ForEach(pragma => pragma.RenderAsPtx(writer));
            }
            else
            {
                // todo. now I've got no idea how to specify pragmas/tuning directives when params ain't empty
                if (nontrivial_tuning || nonempty_pragmas) throw AssertionHelper.Fail();
            }

            // For PTX ISA version 1.4 and later, parameter variables are declared in the kernel
            // parameter list. For PTX ISA versions 1.0 through 1.3, parameter variables are
            // declared in the kernel body.
            if (Version >= SoftwareIsa.PTX_14)
            {
                if (Params.IsEmpty()) writer.WriteLine("()");
                else
                {
                    writer.WriteLine(" (");
                    indent();

                    Params.ForEach((p, i) =>
                    {
                        if (i != 0) writer.WriteLine(",");
                        p.RenderAsPtx(writer);
                    });

                    outdent();
                    writer.WriteLine(")");
                }
            }

            var render_stmts = new List<Action>();
            var decls = new Dictionary<String, List<int>>();
            Action<Slot> mention = s =>
            {
                var m = s.RenderAsPtx().AssertParse(@"^(?<base>.*?)(?<index>\d*)$");
                var @base = m["base"];
                var index = m["index"].IsEmpty() ? -1 : int.Parse(m["index"]);
                if (m["index"].StartsWith("0") && m["index"] != "0") index = -1;

                if (s is Reg && index != -1)
                {
                    var lst = decls.GetOrCreate(@base, () => new List<int>());
                    lst.Add(index);
                }
                else
                {
                    decls.Add(s.RenderAsPtx(), new List<int>());
                }
            };

            foreach (var stmt in Stmts)
            {
                render_stmts.Add(() =>
                {
                    if (stmt is Label)
                    {
                        outdent();
                        stmt.RenderAsPtx(writer);
                        writer.WriteLine(":");
                        indent();
                    }
                    else if (stmt is Instruction)
                    {
                        stmt.RenderAsPtx(writer);
                        writer.WriteLine(";");
                    }
                    else
                    {
                        throw AssertionHelper.Fail();
                    }
                });

                var op = stmt as ptxop;
                if (op != null) op.Operands.ForEach(arg =>
                {
                    Action<Expression> extract_vars = null;
                    extract_vars = e =>
                    {
                        var e_reg = e as Reg;
                        if (e_reg != null) mention(e_reg);

                        var e_var = e as Var;
                        if (e_var != null)
                        {
                            var new_style_param = e_var.Space == param && Version >= SoftwareIsa.PTX_14;
                            if (!new_style_param) mention(e_var);
                        }

                        var e_sreg = e as Sreg;
                        if (e_sreg != null) return;

                        var e_const = e as Const;
                        if (e_const != null) return;

                        var e_warp_sz = e as WarpSz;
                        if (e_warp_sz != null) return;

                        var e_vec = e as Vector;
                        if (e_vec != null) e_vec.Flatten().ForEach(e_sub => extract_vars(e_sub));

                        var e_label = e as Label;
                        if (e_label != null) return;

                        var e_modded = e as Modded;
                        if (e_modded != null) e_modded.Flatten().ForEach(e_sub => extract_vars(e_sub));
                    };

                    extract_vars(arg);
                });
            }

            writer.WriteLine("{");
            indent();

            // todo. also implement this:
            // texrefs and samplerrefs might only be param or global
            // in the latter case they're module-wide
            decls.Keys.Order().ForEach(k =>
            {
                var min = decls[k].MinOrDefault(-1);
                var max = decls[k].MaxOrDefault(-1);
                if (min < 0 || max < 0) writer.WriteLine(k + ";");
                else writer.WriteLine(k + "<" + max + ">");
            });

            render_stmts.RunEach();

            outdent();
            writer.WriteLine("}");
        }
    }
}